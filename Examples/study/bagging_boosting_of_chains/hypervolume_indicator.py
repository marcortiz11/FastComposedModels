from Source.genetic_algorithm.fitting_functions import f1_3objective_acc_time_param as f
from Source.genetic_algorithm.fitting_functions import make_limits_dict, update_limit_dict
from Examples import metadata_manager_results as results_manager
from sortedcontainers import SortedSet as sortset
import matplotlib.pyplot as plt
import Source.io_util as io
import numpy as np
import os


def select_reference_NN(R, phase="test"):
    models = dict([(k, r) for k, r in R.items() if len(r.val if phase == "val" else r.test) < 3])
    model_ids = list(models.keys())
    best = np.argmax([R[id].test['system'].accuracy if phase == "test" else R[id].val['system'].accuracy for id in model_ids])
    ref_NN = models[model_ids[best]]
    return ref_NN


def compute_hvolume(r: np.ndarray, obj: np.ndarray) -> float:
    """
    Hypervolume computation algorithm from Beume.N et al 2009
    :param r: 1x3 np array. Reference point
    :param obj: Nx3 nparray. Volume contributing points (Ensemble evlauations).
    :return: Hyper volume generated by points in obj with respect to r
    """

    obj -= r  # Time, accuracy and params normalized values relative to reference NN
    valid = np.logical_and(obj[:, 0] > 0, obj[:, 1] > 0)
    valid = np.logical_and(obj[:, 2] > 0, valid)
    valid = np.where(valid == True)
    obj = obj[valid]

    # Numpy not hashable, work with list and tuple
    order_x3 = np.argsort(obj, axis=0)[:0]
    points_x12 = [(arow[1], arow[2]) for arow in obj]
    points_x3 = list(obj[:, 0])

    # Step 1: Initialize algorithm
    V = 0
    s = sortset((float("inf"), 0), (0, float("inf")))

    # Step 2: Process the first point
    A = points_x12[order_x3[0]][0] * points_x12[order_x3[0]][1]
    zi = order_x3[0]

    # Step 3: Process all other points
    for i in order_x3:
        pi = order_x3[i]
        p = points_x12[pi, :]
        qi = s.bisect_right(p)+1
        q = s[qi]
        if p[1] > q[1]:
            V += A * (points_x3[zi] - points_x3[pi])
            zi = pi
            ti = qi-1
            while p[1] > s[ti][1]:
                t = s[ti]
                A -= (t[0] - s[ti-1][0]) * (t[1] - q[1])
                s.remove(t)
                ti -= 1
            t = s[ti]
            A += (p[0] - t[0]) * (p[1] - q[1])
            s.add(p)
    return V


if __name__ == "__main__":

    ################### Plot configurations #########################
    experiment = 'bagging_boosting_of_chains_GA'
    plt.rcParams.update({'font.size': 12})
    GA_results_metadata_file = os.path.join(os.environ['FCM'],
                                            'Examples',
                                            'compute',
                                            experiment,
                                            'results',
                                            'metadata.json')

    ids = []

    phase = "val"
    labels = ["EARN pm=0.8", "GP pm=0.8", "EARN pm=0.5", "GP pm=0.5"]
    line_style = [':', '-.', '--', '-']
    cmap = cm.get_cmap('jet')
    colors = cmap(np.linspace(0, 1.0, 4))
    ##################################################################

    plt.figure()
    limits = make_limits_dict()

    for j, id in enumerate(ids):
        GA_res_loc = results_manager.get_results_by_id(GA_results_metadata_file, id)
        GA_params = results_manager.get_fieldval_by_id(GA_results_metadata_file, "params")
        individuals_fitness_generation = io.read_pickle(
            os.path.join(GA_res_loc, 'individuals_fitness_per_generation.pkl'))
        R = io.read_pickle(os.path.join(GA_res_loc, 'results_ensembles.pkl'))
        ref_NN = select_reference_NN(R, phase)
        update_limit_dict(limits, R, phase)

        Y_hvolume = []

        for gen in individuals_fitness_generation:
            Rgen = [R[g] for g in gen]
            obj = f(Rgen, GA_params['a'], limits, phase)
            ref = f([ref_NN], GA_params['a'], limits, phase)
            Y_hvolume.append(compute_hvolume(ref, obj))

        plt.plot(Y_hvolume, label=id)

    plt.legend()
    plt.show()
